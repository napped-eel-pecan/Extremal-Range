#' The following includes functions that are useful in creating and manipulating
#' random field objects.


#' Convert a random field object into a matrix.
#' 
#' This function converts a random field object into a matrix.
#' @param RF A random field object
#' @return A matrix corresponding to RF$Z with the corerct dimensions
#' @export
RF2matrix = function(RF){
  M = RF$Z
  dim(M) = RF$dim
  return(M)
}


#' Convert a matrix into a random field object.
#' 
#' This function converts a matrix into a random field (RF) object.
#' @param M A matrix to be converted into an RF object
#' @param x A vector representing the x-coordinates (rows) of the matrix
#' @param y A vector representing the y-coordinates (columns) of the matrix
#' @return A list representing the RF object with elements X, Y, Z, and dim
#' @export
matrix2RF = function(M, x, y){
  stopifnot(all(dim(M) == c(length(x), length(y))) | is.vector(M))
  return(list("X"= rep(x, times = length(y)), # rows of the matrix
              "Y"= rep(y, each = length(x)), # columns of the matrix
              "Z"= as.vector(M),
              "dim" = c(length(x), length(y))))
}


#' Generate Covariance Function Based on Specified Model
#'
#' This function returns a covariance function corresponding to the chosen model type. 
#' Supported models include Gaussian, Exponential, and Matérn. The function produces a 
#' closure that computes the covariance given a distance input, allowing for flexible 
#' spatial or temporal modeling.
#'
#' @param model A character string specifying the type of covariance model. 
#'     Must be one of `"Gauss"` (Gaussian), `"Exp"` (Exponential), or `"Matern"` (Matérn).
#' @param range A numeric value defining the range parameter for the covariance function. 
#'     Defaults to `1`. This parameter scales the distance in the covariance calculation.
#' @param nu A numeric value specifying the smoothness parameter for the Matérn covariance function. 
#'     Defaults to `1.5`. This parameter is relevant only if `model` is set to `"Matern"`.
#'
#' @return A function that computes the covariance value for a given distance. 
#'     The returned function accepts a numeric distance `h` and returns the corresponding covariance value.
#' @export
covModel = function(model, range = 1, nu = 1.5){
  if (model == "Gauss"){
    cov_fun = function(h){
      h = h/range
      return(exp(-h^2 / 2))
    }
  } else if (model == "Exp"){
    cov_fun = function(h){
      h = h/range
      return(exp(-h))
    }
  } else if (model == "Matern"){
    cov_fun = function(h){
      res = h*0 + 1
      change = which(h > 0)
      h = h/range
      res[change] = (2^(1-nu)) / gamma(nu) * (sqrt(2 * nu) * h[change])^nu * besselK(sqrt(2 * nu) * h[change], nu)
      return(res)
    }
  } else {
    stop("Unknown model type. Please choose 'Gauss', 'Exp', or 'Matern'.")
  }
  return(cov_fun)
}

#' Generate Gaussian Random Fields
#' 
#' This function creates a generator object capable of producing independent and identically distributed (iid) replicates of a Gaussian random field (GRF). It takes in spatial coordinates, a covariance function, and optional conditioning sites, and outputs a generator that can efficiently simulate random fields according to the specified covariance structure.
#'
#' @param x A numeric vector representing the x-coordinates of the spatial grid.
#' @param y A numeric vector representing the y-coordinates of the spatial grid.
#' @param cov_fun A covariance function, typically generated by `covModel`, that defines the spatial correlation structure.
#' @param method A character string specifying the decomposition method to use for generating the random field. Options are `"chol"` for Cholesky decomposition or `"eig"` for eigenvalue decomposition. Defaults to `"eig"`.
#' @param cond_sites An optional data frame or matrix with two columns, representing the x- and y-coordinates of the conditioning sites. If provided, the random field will be conditioned on the values at these sites.
#'
#' @return A generator object that can be used to produce Gaussian random fields. 
#'     The object contains the decomposition of the covariance matrix, the grid information, and the conditioning structure if applicable.
#' @export
#' @examples
#' x = y = seq(-5, 5, length.out = 40)
#' cond_sites = data.frame(x = c(-3, 3), y = c(0, 0))
#' gen = randomFieldGenerator(x, y, covModel("Gauss"), method = "eig", cond_sites = cond_sites)
#' for (i in 1:5){
#'   RF = generateRF(gen, cond_val = c(4, -4))
#'   plotRF(RF)
#'   Sys.sleep(1)
#' }
randomFieldGenerator = function(x, y, cov_fun, method = "eig", cond_sites = NULL){
  grid <- expand.grid(x = x, y = y)
  if (!is.null(cond_sites)){
    method = "eig"
    cond_sites = data.frame(cond_sites)
    names(cond_sites) = c("x", "y")
    grid = rbind(grid, cond_sites)
  }
  dist_matrix <- as.matrix(dist(grid))
  cov_matrix <- cov_fun(dist_matrix)
  if (!is.null(cond_sites)){
    q = length(x)*length(y)
    N = nrow(cov_matrix)
    Sigma11 = cov_matrix[1:q, 1:q]
    Sigma21 = cov_matrix[(q+1):N, 1:q]
    Sigma12 = cov_matrix[1:q, (q+1):N]
    Sigma22 = cov_matrix[(q+1):N, (q+1):N]
    reg_coeff = Sigma12 %*% solve(Sigma22)
    cov_matrix = Sigma11 - reg_coeff %*% Sigma21
  } else {
    reg_coeff = NULL
  }
  if (method == "chol"){
    library(Matrix)
    cov_matrix <- as.matrix(nearPD(cov_matrix)$mat)
    L <- chol(cov_matrix)  # Cholesky decomposition
  } else if (method == "eig"){
    eig <- eigen(cov_matrix)
    # Ensure non-negative eigenvalues
    eig$values[eig$values < 0] = 0
    L = eig$vectors %*% diag(sqrt(eig$values))
  } else {
    stop('randomFieldGenerator: Please select either "chol" or "eig" as the method.')
  }
  obj = list("L" = L,
             "x" = x,
             "y" = y,
             "cond_sites" = cond_sites,
             "reg_coeff" = reg_coeff)
  class(obj) = "Generator"
  return(obj)
}

#' Estimate Computation Time for Generating a Gaussian Random Field
#'
#' This function provides an estimated computation time for generating a Gaussian random field 
#' based on the specified grid size and decomposition method. It performs a timed test on a smaller 
#' grid and scales the result to predict the time required for the full grid.
#'
#' @param x A numeric vector representing the x-coordinates of the grid. The length of this vector 
#'     determines the grid size along the x-axis.
#' @param y A numeric vector representing the y-coordinates of the grid. The length of this vector 
#'     determines the grid size along the y-axis.
#' @param method A character string specifying the method for decomposition in the random field generation. 
#'     Options are `"chol"` for Cholesky decomposition or `"eig"` for eigenvalue decomposition. 
#'     Defaults to `"eig"`.
#'
#' @return The function prints an estimated computation time in minutes for generating the Gaussian 
#'     random field over the specified grid. This estimate is based on a timing test performed on a smaller grid.
#' @export
time2generateRF = function(x, y, method = "eig"){
  n = length(x)*length(y)
  N_test = 35 # larger for higher precision but takes longer.
  x = y = seq(-5, 5, length.out = N_test)
  start_time = Sys.time()
  L = randomFieldGenerator(x, y, covModel("Gauss"), method)
  duration = Sys.time() - start_time
  mins = as.numeric(duration * exp(3 * log(n/N_test^2)) / 60)
  cat("Estimated computation time:", round(mins), "minutes\n")
}

#' Generate a Gaussian Random Field from a Generator Object
#'
#' This function generates a realization of a Gaussian random field (GRF) based on a given generator object. The generator object, created by `randomFieldGenerator`, encapsulates the spatial grid, the decomposition of the covariance matrix, and optional conditioning structure, allowing for efficient simulation of the GRF.
#'
#' @param generator A generator object created by `randomFieldGenerator`, containing the necessary components to simulate a Gaussian random field.
#' @param cond_val An optional numeric vector providing the values at the conditioning sites. This should correspond to the number of conditioning sites specified in the `cond_sites` parameter when creating the generator. If the generator includes conditioning, this argument is required.
#'
#' @return A random field object, with dimensions corresponding to the spatial grid defined in the generator object. If conditioning is applied, the field will reflect the specified values at the conditioning sites.
#' @export
generateRF = function(generator, cond_val = NULL){
  Z <- rnorm(ncol(generator$L))  # Generate independent standard normal variables
  if (!is.null(generator$cond_sites)){
    if (is.null(cond_val)){
      stop("generateRF: Please provide values for the conditioning sites.")
    }
    mu = generator$reg_coeff %*% cond_val
  } else {
    mu = 0
  }
  field <- as.vector(generator$L %*% Z + mu) # Generate the GRF
  return(matrix2RF(field, generator$x, generator$y))
}


#' Plot a Random Field and its excursion sets
#'
#' This function generates an image plot of an excursion set for a given random field (RF) object. 
#' An excursion set consists of the regions where the random field exceeds a specified threshold value.
#' The plot is rendered in grayscale, highlighting the areas of interest.
#'
#' @param RF A random field object containing the spatial data to be plotted.
#' @param u A numeric threshold value; the excursion set will include regions where the random field 
#'     values exceed this threshold. If `u` is not provided, the entire random field is plotted with contours.
#'
#' @return An image plot visualizing the excursion set, with areas exceeding the threshold value `u` 
#'     displayed in grayscale.
#' @export
plotRF = function(RF, u = NA){
  dim(RF$Z) = RF$dim
  X = unique(RF$X)
  Y = unique(RF$Y)
  if (is.na(u)){
    image(X, Y, RF$Z)
    contour(X, Y, RF$Z, add = TRUE)
  } else {
    Z = RF$Z > u
    image(X, Y, Z, col=gray.colors(2,start=1,end=0.5))
  }
}


#' Plots the proportion of area in a ball of radius x centered at x0 covered by the excursion set.
#' @param RF A two-dimensional random field object
#' @param u The threshold to take the excursion set at
#' @param max_dist The largest distance to compute in the extent profile. Defaults to Inf.
#' @param x0 The center of the ball.
#' @return A list with names x and y corresponding to the vectors of x and y coordinates of the points in the extent profile. 
#' call plot(extent_profile(...)) to see the result.
#' @export
extent_profile = function(RF, u, max_dist = Inf, x0 = c(0, 0)){
  get_representatives = function(vec){
    vec = sort(vec)
    N = length(vec)
    is_representative = rep(FALSE, N)
    for (i in N:1){
      current = vec[i]
      if (i == N){
        is_representative[i] = TRUE
      } else {
        if (current < prev){
          is_representative[i] = TRUE
        }
      }
      prev = current
    }
    inds_representatives = which(is_representative)
    representatives = vec[inds_representatives]
    return(list("reps" = representatives,
                "counts" = inds_representatives))
  }
  
  len = function(vec){
    return(norm(vec, type = "2"))
  }
  
  distances = apply(cbind(RF$X - x0[1], RF$Y - x0[1]), MARGIN = 1, len)
  keep_only = which(distances <= max_dist)
  distances = distances[keep_only]
  RF$Z = RF$Z[keep_only]
  representatives_all = get_representatives(distances)
  
  inds_exceedances = which(RF$Z >= u)
  distances_to_exceedances = distances[inds_exceedances]
  representatives_exceedances = get_representatives(distances_to_exceedances)
  
  N = length(representatives_all$reps)
  inds = rep(NA, N)
  for (i in N:1){
    M = length(representatives_exceedances$reps)
    current = representatives_all$reps[i]
    while (representatives_exceedances$reps[M] > current){
      M = M - 1
    }
    inds[i] = M
  }
  ratios = representatives_exceedances$counts[inds] / representatives_all$counts
  return(list("x" = representatives_all$reps, "y" = ratios))
}


#' From an extent profile, get a function that computes the tail dependence coefficient.
#' The extent profile should be an average of many realizations.
#' @param ep The extent profile (see extent_profile documentation)
#' @param new_x The distances where to compute the tail dependence coefficients.
#' @return a list containing two elements: x with value x_new and y with the values of the tail dependence coefficient at the specified distances.
#' @export
tail_dependence_fun = function(ep, new_x = NULL){
  if (is.null(new_x)){
    new_x = ep$x
  }
  # Fit a spline
  spline_fit <- smooth.spline(ep$x, ep$y,
                              spar = 0.95,
                              w = c(1e10, rep(1, length(ep$x)-1)))
  
  # plot(ep)
  # lines(spline_fit)
  new_y = predict(spline_fit, new_x)$y + new_x/2*predict(spline_fit, new_x, deriv = 1)$y
  slope_at_0 = 3/2*predict(spline_fit, 0, deriv = 1)$y
  res = list("x" = new_x,
             "y" = new_y,
             "slope_at_0" = slope_at_0)
  return(res)
}


#' Calculate the density of a set of positive observations at 0
#' 
#' This function calculates the slope of the PDF of a vector x>=0 at 0.
#' @param x the vector of non-negative observations
#' @return the height of the estimated probability density of the observations at 0
#' @export
density_at_zero = function(x){
  bad_inds = which(!is.finite(x))
  if (length(bad_inds) > 0) x[bad_inds] = max(x[-bad_inds])
  f = ecdf(x)
  # plot(f, xlim = c(0,max(x)))
  xy = cbind(x, f(x))
  if (length(bad_inds) > 0) xy = xy[-bad_inds,]
  xy = rbind(c(0,0), xy)
  # Fit a spline
  spline_fit <- smooth.spline(xy[,1], xy[,2],
                              spar = 0.99,
                              w = c(1e10, rep(1, nrow(xy)-1)))
  # lines(predict(spline_fit, sort(xy[,1])))
  return(predict(spline_fit, 0, deriv = 1)$y)
}


#' Generate a Student Random Field (Conditionally)
#'
#' @param generator A randomFieldGenerator object.
#' @param k An integer specifying the degrees of freedom for the Student's t distribution. 
#'     Defaults to `3`.
#' @param thresh A numeric value specifying the threshold for the conditional distribution. 
#'     Defaults to `-Inf`, meaning no threshold condition.
#'
#' @return A random field (generateRF) object.
studentRF = function(generator, k = 3, thresh = -Inf){
  conds = NULL
  while(is.finite(thresh)){
    conds = rnorm(k+1)
    if (conds[k+1]/sqrt(sum(conds[-(k+1)]^2)/k)*sqrt((k-2)/k) > thresh) break
  }
  X = generateRF(generator, cond_val = conds[k+1])
  denom = rep(0, length(X$Z))
  for (i in 1:k){
    denom = denom + generateRF(generator, conds[i])$Z^2
  }
  denom = sqrt(denom / k)
  X$Z = X$Z/denom*sqrt((k-2)/k)
  return(X)
}


#' Generate a Chi-Square Random Field (Conditionally)
#'
#' @param generator A randomFieldGenerator object.
#' @param k An integer specifying the degrees of freedom for the chi-square distribution. 
#'     Defaults to `3`.
#' @param thresh A numeric value specifying the threshold for the conditional distribution. 
#'     Defaults to `-Inf`, meaning no threshold condition.
#'
#' @return A random field (generateRF) object.
chi2RF = function(generator, k = 3, thresh = -Inf){
  conds = NULL
  while(is.finite(thresh)){
    conds = rnorm(k)
    if (1/sqrt(2*k)*(sum(conds^2)-k) > thresh) break
  }
  total = rep(0, ncol(generator$L))
  for (i in 1:k){
    Xi = generateRF(generator, cond_val = conds[i])
    total = total + Xi$Z^2
  }
  Xi$Z = 1/sqrt(2*k)*(total - k)
  return(Xi)
}


#' Generate Pareto Distributed Random Variables
#'
#' @param n An integer specifying the number of random variables to generate.
#' @param alpha A numeric value specifying the shape parameter of the Pareto distribution. 
#'     Defaults to `1`.
#'
#' @return A numeric vector of random variables from the Pareto distribution.
rpareto = function(n, alpha = 1){
  return(runif(n)^(-1/alpha))
}


#' Generate a Pareto-Scaled Random Field (Conditionally)
#'
#' @param generator A randomFieldGenerator object.
#' @param thresh A numeric value specifying the threshold for the conditional distribution. 
#'     Defaults to `-Inf`, meaning no threshold condition.
#' @param alpha A numeric value specifying the shape parameter of the Pareto distribution. 
#'     Defaults to `1`.
#'
#' @return A random field (generateRF) object, with Pareto-distributed scaling.
mixtureRF = function(generator, thresh = -Inf, alpha = 1){
  while(TRUE){
    W = rnorm(1)
    Lambda = rpareto(1, alpha = alpha)
    if(W*Lambda >= thresh) break
  }
  RF = generateRF(gen, cond_val = W)
  RF$Z = RF$Z * Lambda
  return(RF)
}


#' Generate a Gaussian Random Variable Above a Threshold
#'
#' @param u A numeric value specifying the lower bound for the generated sample. 
#'     If `u` is greater than `3`, the function uses an exponential approximation.
#'
#' @return A numeric value sampled from a Gaussian distribution with the specified threshold.
gauss_above = function(u){
  if (u > 3){
    return(u + rexp(1,u))
  } else {
    while(TRUE){
      W = rnorm(1)
      if(W >= u){
        return(W)
      }
    }
  }
}
